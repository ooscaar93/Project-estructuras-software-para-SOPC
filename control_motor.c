/*                                                                  
 * DC motor control
 * This program has two real-time threads:
 * 1) thread1: associated to function thread1_control. This tread's "while true" runs
 * 	  once every 100 ms (sampling period). Computes the RPMs of the motor based on the
 * 	  decoder's count, sets decoder's count to zero, computes control signal uk, gene-
 * 	  rates PWM and polarity signal for H bridge, sends monitorization data to bridge.py
 * 	  (client) via UNIX socket (this tread acts as server) and updates setpoint value
 * 	  whenever commands_subscriber.py (other client) sends a new value to this tread
 * 	  (server).
 * 2) thread2: associated to function trhead2_control. This tread's "whilw true" sets
 *    up a function called edgeDetected that runs whenever an event is registered in
 *    GPIO_SA or GPIO_SB (ports of quadrature encoder). This function acts as a state
 * 	  machine that computes a count used to determine the RPMs of the motor.
 */
 
 // When compiling, -lpigpio option must be used to include pigpio library.
 
#include <limits.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <time.h>
#include <pigpio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>

/* Constant definition */
#define NSEC_PER_SEC 1000000000		// number of ns in a second
#define TS 100000000				// sampling period (100 ms, in ns)

#define V_DC 6.0					// supply voltage of H bridge

#define TO_RPM 60.0/(159.0*0.1*4.0)	// factor to compute RPMs from decoder count

/* Definition of discrete PI controller parameters: uk = B0*ek+B1*ek1-A1*uk1 */
#define B0 0.005455
#define B1 0.003455
#define A1 -1.0

/* Definition of used GPIO ports */
#define GPIO_PWM 18			// GPIO for output PWM, goes to pin EN of H bridge 
#define GPIO_DIR 17			// GPIO connected t DIR pin of H bridge, to output uk's polarity
#define GPIO_SA 22			// GPIO input generated by encoder SA
#define GPIO_SB 23			// GPIO input generated by encoder SB

/* Declaration of global variables */
int encoder_cont;			// count of decoder state machine

/* Declarations needed to create socket server to send data to bridge.py */
int server_socket;			// server socket descriptor
int client_socket;			// client socket descriptor
struct sockaddr_un server_addr;		// server address
struct sockaddr_un client_addr;		// client address

/* Declarations needed to create socket server to receive data from commands_subscriber.py */ 
int server_socket2;			// server socket descriptor
int client_socket2;			// client socket descriptor
struct sockaddr_un server_addr2;		// server address
struct sockaddr_un client_addr2;		// client address

/* using clock_nanosleep of librt */
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
      __const struct timespec *__req,
      struct timespec *__rem);

/* the struct timespec consists of nanoseconds and seconds. if the nanoseconds are getting
 * bigger than 1000000000 (= 1 second) the variable containing seconds has to be
 * incremented and the nanoseconds decremented by 1000000000.
 */
static inline void tsnorm(struct timespec *ts)
{
   while (ts->tv_nsec >= NSEC_PER_SEC) {
      ts->tv_nsec -= NSEC_PER_SEC;
      ts->tv_sec++;
   }
}

/* 
 * This function runs whenever an event is produced on GPIO_SA or GPIO_SB
 * State machine of quadrature decoder
 */
void edgeDetected(int gpio, int level, uint32_t tick)
{	
	// declaration of static variables
	static int a = 0;		// value of GPIO_SA (encoder disk A)
	static int b = 0;		// value of GPIO_SB (encoder disk B)
	static int estado = 1;	// actual state of decoder state machine (from 1 to 4)
	
	// actualization of variables a and b
	if (gpio == GPIO_SA) {		// edge in SA
		if (level == 1) {		// rising edge in SA
			a = 1;
		}
		else if (level == 0) {	// falling edge in SA
			a = 0;
		}
	}
	else if (gpio == GPIO_SB) {	// edge in SB		
		if (level == 1) {		// rising edge in SB
			b = 1;
		}
		else if (level == 0) {	// falling edge in SB
			b = 0;
		}
	}
	
	// state machine for increment/decrement of encoder_cont
	// states (a,b): 1 (0,0), 2 (1,0), 3 (1,1), 4 (0,1)
	switch (estado) {
		case 1:					// a == 0, b == 0
			if (a == 1 && b == 0) {		// if rising edge in a
				estado = 2;		// --> a == 1, b == 0 (state 2)
				encoder_cont--;
			}
			else if (a == 0 && b == 1) {	// if rising edge in b
				estado = 4;		// --> a == 0, b == 1 (state 4)
				encoder_cont++;
			}
			break;
		case 2:					// a == 1, b == 0
			if (a == 1 && b == 1) {		// if rising edge in b
				estado = 3;		// --> a == 1, b == 1 (state 3)
				encoder_cont--;
			}
			else if (a == 0 && b == 0) {	// if falling edge in a
				estado = 1;		// --> a == 0, b == 0 (state 1)
				encoder_cont++;
			}
			break;
		case 3:					// a == 1, b == 1
			if (a == 0 && b == 1) {		// if falling edge in a
				estado = 4;		// --> a == 0, b == 1 (state 4)
				encoder_cont--;
			}
			else if (a == 1 && b == 0) {	// if falling edge in b
				estado = 2;		// --> a == 1, b == 0 (state 2)
				encoder_cont++;
			}
			break;
		case 4:					// a == 0, b == 1
			if (a == 0 && b == 0) {		// if falling edge in b
				estado = 1;		// --> a == 0, b == 0 (state 1)
				encoder_cont--;
			}
			else if (a == 1 && b == 1) {	// if rising edge in a
				estado = 3;		// --> a == 1, b == 1 (state 3)
				encoder_cont++;
			}
			break;

	}
	
}

/* Thread1: computation of control signal */
void *thread1_control(void *data)
{		
	struct timespec t;
	
	/* declaration of variabe with setpoint in RPM */
	float sp = 0.0;		// setpoint is initialized to 0.0 RPM
	
	/* declaration of variable with copy of encoder_cont */
	int encoder_cont_k;
	
	/* declaration of variable with speed in RPM */
	float rpm;

	/* declaración de las variables del controlador discreto */
	float ek, ek1;			// error en k y en k-1
	float uk, uk1;			// señal de control en k y en k-1
	float uk_sat_dz;		// señal de control saturada y con zona muerta
	
	/* declaración de variables con el número de bytes de algunas variables */
	int tsec_bytes = sizeof t.tv_sec;	// tamaño en bytes de t.tv_sec
	int tnsec_bytes = sizeof t.tv_nsec;	// tamaño en bytes de t.tv_nsec
	int rpm_bytes = sizeof rpm;		// tamaño en bytes de rpm
	int uk_bytes = sizeof uk;		// tamaño en bytes de uk
	
	/* initialization of ek1 and uk1 with null initial conditions */
	ek1 = 0.0;
	uk1 = 0.0;
	
	/* initialization of encoder count to 0*/
	encoder_cont = 0;
	
	/* declaration of variables with duty cycle of PWM and polarity */
	float dc_float;		// duty cycle in float, between 0 and 1
	int dc;				// duty cycle in int, between 0 and a million
	int dir = 1;		// 0 if uk positive, 1 if uk negative
	
	/* get current time */
	clock_gettime(0,&t);
	
	/* start after one second for synchronization */
	t.tv_sec++;
	
	while(1){
		/* wait until next shot */
		clock_nanosleep(0, TIMER_ABSTIME, &t, NULL);
		
		/* compute RPMs from encoder_cont */
		encoder_cont_k = encoder_cont;		// copy decoder count
		encoder_cont = 0;					// set to zero decoder count
		rpm = encoder_cont_k*TO_RPM;		// compute RPMs
		
		/* compute error signal */
		ek = sp - rpm;
		
		/* compute control signal (discrete PI) */
		uk = B0*ek+B1*ek1-A1*uk1;
		
		/* saturate */
		if (uk > 6.0) {					// if uk > 6 volts, 6 volts
			uk = 6.0;
		}
		else if (uk < -6.0) {			// si uk < -6 volts, -6 volts
			uk = -6.0;
		}
		
		/* apply deadzone if abs(uk) < 0.6 */
		if (uk > 0.0 && uk < 0.6) {
			uk = 0.0;
		}
		else if (uk < 0.0 && uk > -0.6) {
			uk = 0.0;
		}
		
		/* apply dead period if polarity changes and set up voltage polarity */
		if (uk > 0.0 && uk1 < 0.0) {		// dead zone if uk goes from negative to positive
			uk_sat_dz = 0.0;
		}
		else if (uk < 0.0 && uk1 > 0.0) {	// dead zone if uk goes from positive to negative
			uk_sat_dz = 0.0;
		}
		else if (uk >= 0.0) {		// uk positive
			uk_sat_dz = uk;
			dir = 1;
		}
		else {				// uk negative
			uk_sat_dz = -uk;
			dir = 0;
		}
		
		/* update polarity signal output */
		gpioWrite(GPIO_DIR, dir);
		
		/* update PWM duty cycle */
		dc_float = uk_sat_dz / V_DC;		// duty cycle in float (between 0 and 1)
		dc = (int)(dc_float*1000000.0);		// duty cycle in int (between 0 and a million)
		gpioHardwarePWM(GPIO_PWM, 2000, dc);	// PWM of 2 kHz in GPIO_PWM with dc duty cycle
		
		/* registrate control and error signal */
		uk1 = uk;
		ek1 = ek;
		
		// Accept an incoming connection from the client bridge.py
		int clen = sizeof(client_addr);	// Get number of bytes of client_addr
		// accept() takes the server socket as an argument and retrieves the first socket connection in the queue,
		// creates a new socket for communication with client and returns the file descriptor for that socket
		client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &clen);
		if (client_socket >= 0) {	// If connection with client has been established
			// Write to client
			write(client_socket, &t.tv_sec, tsec_bytes);	// use client socket file descriptor to send t.tv_sec
			write(client_socket, &t.tv_nsec, tnsec_bytes);	// use client socket file descriptor to send t.tv_nsec
			write(client_socket, &rpm, rpm_bytes);	// use client socket file descriptor to send rpm
			write(client_socket, &uk, uk_bytes);	// use client socket file descriptor to send uk
			// Close socket connection to client
			close(client_socket);			// use client socket file descriptor
		}
		// If connection from client not available, doesn't send data
		
		// Accept an incoming connection from the client commands_subscriber.py
		int clen2 = sizeof(client_addr2);	// Get number of bytes of client_addr
		// accept() takes the server socket as an argument and retrieves the first socket connection in the queue,
		// creates a new socket for communication with client and returns the file descriptor for that socket
		client_socket2 = accept(server_socket2, (struct sockaddr *) &client_addr2, &clen2);
		if (client_socket2 >= 0) {	// If connection with client has been established
			// Receive float data
			float received_float;
			ssize_t total_bytes_received = 0;
			ssize_t bytes_received;

			// Receive bytes into a buffer
			uint8_t buffer[sizeof(float)];
			
			// Loop until  all bytes from the float have been received
			while (total_bytes_received < sizeof(float)) {
				// Receive bytes from client
				bytes_received = recv(client_socket2, buffer + total_bytes_received, sizeof(float) - total_bytes_received, 0);
				if (bytes_received < 0) {		// check if there is reception error
					printf("Receive failed\n");
					break;
				} else if (bytes_received == 0) {
					printf("Connection closed by client\n");	// check if client has closed the connection
					break;
				} else {
					total_bytes_received += bytes_received;		// update total bytes
				}
			}
			
			// If reception uncomplete, prints error and doesn't update setpoint
			if (total_bytes_received != sizeof(float)) {
				printf("Incomplete float data received\n");
			}
			else {
				// Interpret the received bytes as a float (assuming little-endian format)
				memcpy(&received_float, buffer, sizeof(float));
				sp = received_float;
			}
			
			close(client_socket2);
		}
		// If connection from client not available, doesn't read setpoint data
		
		/* calculate next shot */
		t.tv_nsec+=TS;
		tsnorm(&t);
	}
	return NULL;
}

/* Thread 2: acquire encoder signal and compute encoder_cont with decoder state machine */
void *thread2_encoder(void *data)
{	
	int ret;
	encoder_cont = 0;	// set encoder_cont to 0
	
	/* Set up a callback for GPIO events in GPIO_SA */
	ret = gpioSetAlertFunc(GPIO_SA, edgeDetected);
	if (ret) {
		printf("Failed to set callback function.\n");
		gpioTerminate();
		return NULL;
	}
	ret = gpioSetAlertFunc(GPIO_SB, edgeDetected);

	if (ret) {
		printf("Failed to set callback function.\n");
		gpioTerminate();
		return NULL;
	}
	
}

/* This functions initializes and setups GPIOs */
int gpio_init()
{
	int ret;
	
	/* Initialize GPIO */
	ret = gpioInitialise();
	if (ret < 0) {
		printf("Failed to initialize GPIO.\n");
		gpioTerminate();
		return ret;
	}
	
	/* Setup GPIO_SA as input */
	ret = gpioSetMode(GPIO_SA, PI_INPUT);
	if (ret) {
		printf("Failed to set GPIO pin mode.\n");
		gpioTerminate();
		return ret;
	}
	
	/* Setup GPIO_SB as output */
	ret = gpioSetMode(GPIO_SB, PI_INPUT);
	if (ret) {
		printf("Failed to set GPIO pin mode.\n");
		gpioTerminate();
		return ret;
	}
	
	/* Setup GPIO_DIR as output */
	ret = gpioSetMode(GPIO_DIR, PI_OUTPUT);
	if (ret) {
		printf("Failed to set GPIO pin mode.\n");
		gpioTerminate();
		return ret;
	}
	
	/* If everything went ok, return 0 */
	return 0;
}
 
int main(int argc, char* argv[])
{	
	int ret;							// variable to save function return
    struct sched_param param;			// create sched_param structure to setup properties related to scheduler
    pthread_attr_t attr;				// create object of type pthread_attr_t to setup thread attributes
    pthread_t thread1, thread2;			// create two threads of type pthread_t
	
	/* Initialize and setup GPIOs */
	ret = gpio_init();
	if (ret) {
		printf("Error when initialising and configuring GPIOs\n");
		return ret;
	}
	
	/* Create socket on server side (to send data to bridge.py) */
	
	// Delete socket file before creating socket
	remove("/tmp/control_socket");
	
	// Create socket descriptor for server:
	// - Socket family AF_UNIX (UNIX Address Family)
	// - Socket type SOCK_STREAM (end-to-end connection, data is recieved in send order)
	server_socket = socket(AF_UNIX, SOCK_STREAM, 0);
	if (server_socket < 0)
	{
		perror("socket() failed");
		return server_socket;
	}
	
	// Set socket to be non-blocking
	int on = 1;
	ret = ioctl(server_socket, FIONBIO, (char *)&on);
	if (ret < 0)
	{
		perror("ioctl() failed");
	    close(server_socket);
	    return ret;
	}
	
	// Bind socket to a local address on the machine
	server_addr.sun_family = AF_UNIX;				// Set socket family of server sockaddr structure
	strcpy(server_addr.sun_path, "/tmp/control_socket");	// Set path of server sockaddr structure
	int slen = sizeof(server_addr);					// Get number of bytes of server_addr
	ret = bind(server_socket, (struct sockaddr *) &server_addr, slen);	// Bind server_socket to server_addr
	if (ret < 0)
	{
		perror("bind() failed");
		close(server_socket);
		return ret;
	}
	
	// Listen for incoming connections to server_socket, with 1 max connection queue
	ret = listen(server_socket, 1);
	if (ret < 0)
	{
		perror("listen() failed");
		close(server_socket);
		return ret;
	}
	
	/* Create a second socket on server side (to read setpoint) */
	
	// Delete socket file before creating socket
	remove("/tmp/setpoint_socket");
	
	// Create socket descriptor for server:
	// - Socket family AF_UNIX (UNIX Address Family)
	// - Socket type SOCK_STREAM (end-to-end connection, data is recieved in send order)
	server_socket2 = socket(AF_UNIX, SOCK_STREAM, 0);
	if (server_socket2 < 0)
	{
		perror("socket() failed");
		return server_socket2;
	}
	
	// Set socket to be non-blocking
	int on2 = 1;
	ret = ioctl(server_socket2, FIONBIO, (char *)&on2);
	if (ret < 0)
	{
		perror("ioctl() failed");
	    close(server_socket2);
	    return ret;
	}
	
	// Bind socket to a local address on the machine
	server_addr2.sun_family = AF_UNIX;				// Set socket family of server sockaddr structure
	strcpy(server_addr2.sun_path, "/tmp/setpoint_socket");	// Set path of server sockaddr structure
	int slen2 = sizeof(server_addr2);					// Get number of bytes of server_addr
	ret = bind(server_socket2, (struct sockaddr *) &server_addr2, slen2);	// Bind server_socket to server_addr
	if (ret < 0)
	{
		perror("bind() failed");
		close(server_socket2);
		return ret;
	}
	
	// Listen for incoming connections to server_socket, with 1 max connection queue
	ret = listen(server_socket2, 1);
	if (ret < 0)
	{
		perror("listen() failed");
		close(server_socket2);
		return ret;
	}
	
	/* Initialize pthread attributes (default values) */
	ret = pthread_attr_init(&attr);		// initializes the thread attributes object pointed to by attr with default attribute values
	if (ret) {
		printf("init pthread attributes failed\n");
		return ret;
	}

	/* Set a specific stack size  */
	ret = pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN);
	if (ret) {
		printf("pthread setstacksize failed\n");
		return ret;
	}
 
	/* Set scheduler policy and priority of pthread */
	ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
	if (ret) {
		printf("pthread setschedpolicy failed\n");
		return ret;
	}
	param.sched_priority = 90;
	ret = pthread_attr_setschedparam(&attr, &param);
	if (ret) {
		printf("pthread setschedparam failed\n");
		return ret;
	}
	ret = pthread_attr_getschedparam(&attr, &param);
	printf("Param %d", param.sched_priority);
	if (ret) {
		printf("pthread getschedparam failed\n");
		return ret;
	}
    
	/* Use scheduling parameters of attr */
	ret = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
	if (ret) {
		printf("pthread setinheritsched failed\n");
		return ret;
	}
 
	/* Create first pthread with specified attributes */
	ret = pthread_create(&thread1, &attr, thread1_control, NULL);
	if (ret) {
		printf("create pthread failed\n");
		return ret;
	}
	
	/* Create second pthread with specified attributes */
	ret = pthread_create(&thread2, &attr, thread2_encoder, NULL);
	if (ret) {
		printf("create pthread failed\n");
		return ret;
    }
 
	/* Join the thread1 and wait until it is done */
	ret = pthread_join(thread1, NULL);
	if (ret) {
		printf("join pthread failed: %m\n");
		return ret;
	}
		
	/* Join the thread2 and wait until it is done */
	ret = pthread_join(thread2, NULL);
	if (ret) {
		printf("join pthread failed: %m\n");
	}
 
        return 0;
}
